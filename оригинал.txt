// ==UserScript==
// @name         remake
// @namespace    http://tampermonkey.net/
// @version      2024-05-20
// @description  try to take over the world!
// @author       мама твоя лысая шлюшка
// @match        https://starve.io/*
// @run-at       document-start
// @grant        unsafeWindow
// ==/UserScript==
/* workerTimers */ ! function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).fastUniqueNumbers = {}) }(this, function (e) { "use strict"; var t, r = void 0 === Number.MAX_SAFE_INTEGER ? 9007199254740991 : Number.MAX_SAFE_INTEGER, n = new WeakMap, i = function (e, t) { return function (n) { var i = t.get(n), o = void 0 === i ? n.size : i < 1073741824 ? i + 1 : 0; if (!n.has(o)) return e(n, o); if (n.size < 536870912) { for (; n.has(o);) o = Math.floor(1073741824 * Math.random()); return e(n, o) } if (n.size > r) throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!"); for (; n.has(o);) o = Math.floor(Math.random() * r); return e(n, o) } }((t = n, function (e, r) { return t.set(e, r), r }), n), o = function (e) { return function (t) { var r = e(t); return t.add(r), r } }(i); e.addUniqueNumber = o, e.generateUniqueNumber = i, Object.defineProperty(e, "__esModule", { value: !0 }) }), function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports, require("fast-unique-numbers")) : "function" == typeof define && define.amd ? define(["exports", "fast-unique-numbers"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).workerTimersBroker = {}, e.fastUniqueNumbers) }(this, function (e, t) { "use strict"; e.load = function (e) { var r = new Map([[0, function () { }]]), n = new Map([[0, function () { }]]), i = new Map, o = new Worker(e); o.addEventListener("message", function (e) { var t = e.data; if (function (e) { return void 0 !== e.method && "call" === e.method }(t)) { var o = t.params, a = o.timerId, s = o.timerType; if ("interval" === s) { var u = r.get(a); if ("number" == typeof u) { var d = i.get(u); if (void 0 === d || d.timerId !== a || d.timerType !== s) throw new Error("The timer is in an undefined state.") } else { if (void 0 === u) throw new Error("The timer is in an undefined state."); u() } } else if ("timeout" === s) { var f = n.get(a); if ("number" == typeof f) { var l = i.get(f); if (void 0 === l || l.timerId !== a || l.timerType !== s) throw new Error("The timer is in an undefined state.") } else { if (void 0 === f) throw new Error("The timer is in an undefined state."); f(), n.delete(a) } } } else { if (! function (e) { return null === e.error && "number" == typeof e.id }(t)) { var m = t.error.message; throw new Error(m) } var c = t.id, p = i.get(c); if (void 0 === p) throw new Error("The timer is in an undefined state."); var v = p.timerId, h = p.timerType; i.delete(c), "interval" === h ? r.delete(v) : n.delete(v) } }); return { clearInterval: function (e) { var n = t.generateUniqueNumber(i); i.set(n, { timerId: e, timerType: "interval" }), r.set(e, n), o.postMessage({ id: n, method: "clear", params: { timerId: e, timerType: "interval" } }) }, clearTimeout: function (e) { var r = t.generateUniqueNumber(i); i.set(r, { timerId: e, timerType: "timeout" }), n.set(e, r), o.postMessage({ id: r, method: "clear", params: { timerId: e, timerType: "timeout" } }) }, setInterval: function (e, n) { var i = t.generateUniqueNumber(r); return r.set(i, function () { e(), "function" == typeof r.get(i) && o.postMessage({ id: null, method: "set", params: { delay: n, now: performance.now(), timerId: i, timerType: "interval" } }) }), o.postMessage({ id: null, method: "set", params: { delay: n, now: performance.now(), timerId: i, timerType: "interval" } }), i }, setTimeout: function (e, r) { var i = t.generateUniqueNumber(n); return n.set(i, e), o.postMessage({ id: null, method: "set", params: { delay: r, now: performance.now(), timerId: i, timerType: "timeout" } }), i } } }, Object.defineProperty(e, "__esModule", { value: !0 }) }), function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports, require("worker-timers-broker")) : "function" == typeof define && define.amd ? define(["exports", "worker-timers-broker"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).workerTimers = {}, e.workerTimersBroker) }(this, function (e, t) { "use strict"; var r = null, n = function (e, t) { return function () { if (null !== r) return r; var n = new Blob([t], { type: "application/javascript; charset=utf-8" }), i = URL.createObjectURL(n); return (r = e(i)).setTimeout(function () { return URL.revokeObjectURL(i) }, 0), r } }(t.load, '(()=>{var e={67:(e,t,r)=>{var o,i;void 0===(i="function"==typeof(o=function(){"use strict";var e=new Map,t=new Map,r=function(t){var r=e.get(t);if(void 0===r)throw new Error(\'There is no interval scheduled with the given id "\'.concat(t,\'".\'));clearTimeout(r),e.delete(t)},o=function(e){var r=t.get(e);if(void 0===r)throw new Error(\'There is no timeout scheduled with the given id "\'.concat(e,\'".\'));clearTimeout(r),t.delete(e)},i=function(e,t){var r,o=performance.now();return{expected:o+(r=e-Math.max(0,o-t)),remainingDelay:r}},n=function e(t,r,o,i){var n=performance.now();n>o?postMessage({id:null,method:"call",params:{timerId:r,timerType:i}}):t.set(r,setTimeout(e,o-n,t,r,o,i))},a=function(t,r,o){var a=i(t,o),s=a.expected,d=a.remainingDelay;e.set(r,setTimeout(n,d,e,r,s,"interval"))},s=function(e,r,o){var a=i(e,o),s=a.expected,d=a.remainingDelay;t.set(r,setTimeout(n,d,t,r,s,"timeout"))};addEventListener("message",(function(e){var t=e.data;try{if("clear"===t.method){var i=t.id,n=t.params,d=n.timerId,c=n.timerType;if("interval"===c)r(d),postMessage({error:null,id:i});else{if("timeout"!==c)throw new Error(\'The given type "\'.concat(c,\'" is not supported\'));o(d),postMessage({error:null,id:i})}}else{if("set"!==t.method)throw new Error(\'The given method "\'.concat(t.method,\'" is not supported\'));var u=t.params,l=u.delay,p=u.now,m=u.timerId,v=u.timerType;if("interval"===v)a(l,m,p);else{if("timeout"!==v)throw new Error(\'The given type "\'.concat(v,\'" is not supported\'));s(l,m,p)}}}catch(e){postMessage({error:{message:e.message},id:t.id,result:null})}}))})?o.call(t,r,t,e):o)||(e.exports=i)}},t={};function r(o){var i=t[o];if(void 0!==i)return i.exports;var n=t[o]={exports:{}};return e[o](n,n.exports,r),n.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";r(67)})()})();'); e.clearInterval = function (e) { return n().clearInterval(e) }, e.clearTimeout = function (e) { return n().clearTimeout(e) }, e.setInterval = function (e, t) { return n().setInterval(e, t) }, e.setTimeout = function (e, t) { return n().setTimeout(e, t) }, Object.defineProperty(e, "__esModule", { value: !0 }) });

const packets = {
    extPut: 27,
    extTake: 37,
    placeBuild: 22,
    joinTotem: 17,
    angle: 0,
    attack: 36,
    stopAttack: 16,
    chestPut: 1,
    chestTake: 8,
    equip: 34,
    recycle: 18,
    craft: 26,
};

let script = {
    lastHeal: undefined,
    lastHealTime: undefined,
    lastHungry: undefined,
    lastTimer: undefined,
    world: {
        fast_units: {},
        units: {},
    },
    user: {
        id: 0,
        uid: 0,
        team: {},
        cam: {
            x: 0,
            y: 0,
        },
        gauges: {
            health: 200,
            hungry: 100,
            cold: 200,
            water: 100
        },
        alive: false,
        ghost: false,
        gauges: {}
    },
    myPlayer: {
        x: 0,
        y: 0,
        ghost: false,
        angle: 0,
    }
}
const SandstormImage = new Image();
SandstormImage.src = "https://raw.githubusercontent.com/XmreLoux/images/main/sandstorm.png";
const BlizzardImage = new Image();
BlizzardImage.src = "https://raw.githubusercontent.com/XmreLoux/images/main/blizzard.png";
let skins = [];
let lootboxes = [];

let Settings = {
    ColoredSpikes: {
        e: true
    },
    AutoPutRed: {
        k: "KeyV",
        e: false,
    },
    AMB: {
        e: false,
        k: "KeyR",
        a: null,
        t: null,
    },
    AutoFeed: {
        e: true
    },
    AutoSteal: {
        e: false,
        k: "KeyE",
    },
    AutoTotem: {
        e: false,
        k: "KeyH"
    },
    ExtractorInfo: {
        e: true
    },
    ExtractorSteal: {
        e: false,
        k: "KeyI"
    },
    ExtractorPut: {
        e: false,
        k: "KeyP"
    },
    AutoCrown: {
        e: false,
        k: "KeyM"
    },
    SkinChanger_Skin: 233,
    SkinChanger_LootBox: 220,
    gaugesInfo: true,
    tracers: false,
    esp: false,
    textalert: {e: false, t: "none"},
    buildinfo: true,
    toteminfo: true,
    AutoExtractorPut: { e: false, k: "KeyM" },
    AutoExtractorTake: { e: false, k: "KeyM" },
    AutoCraft: { e: false, k: "KeyK", lastcraft: -1, s: false},
    AutoRecycle: { e: false, k: "KeyL", lastrecycle: -1, s: false },
    AutoSpike: { e: false, k: "Space", m: true, p: ["Reidite Spike", "Amethyst Spike", "Diamond Spike", "Gold Spike", "Stone Spike", "Wood Spike", "Wood Wall"] },
}


setTimeout(() => {
    unsafeWindow.kasdgiksadg = {
        KILLUKRSOLIDER: () => {
            let container = document.body;
            let SDGSDsgdASF = new guify({
                title: "externalV1",
                theme: {
                    name: "externalV1",
                    colors: {
                        menuBarBackground: "rgb(0,0,0)",
                        menuBarText: "rgb(255, 0, 0)",
                        panelBackground: "rgb(0,0,0, 0.5)",
                        componentBackground: "rgb(22, 22, 22)",
                        componentForeground: "rgb(212,16,117)",
                        textPrimary: "rgb(201,21,131)",
                        textSecondary: "rgb(212,16,117)",
                        textHover: "rgb(255,255,255)"
                    },
                    font: {
                        fontFamily: "Baloo Paaji",
                        fontSize: "20px",
                        fontWeight: "1"
                    }
                },
                align: "right",
                width: 550,
                barMode: "none",
                panelMode: "none",
                opacity: .6,
                root: unsafeWindow.container,
                open: !0
            });
            delete unsafeWindow.guify
            SDGSDsgdASF.Register({
                type: "folder",
                label: "Visuals",
                open: !1
            })
            SDGSDsgdASF.Register({
                type: "folder",
                label: "Misc",
                open: !1
            })
            SDGSDsgdASF.Register({
                type: "folder",
                label: "AutoSpike",
                open: !1
            })
            SDGSDsgdASF.Register({
                type: "folder",
                label: "AutoCraft & AutoRecycle",
                open: !1
            })
            SDGSDsgdASF.Register({
                type: "folder",
                label: "Bind",
                open: !1
            })
            SDGSDsgdASF.Register({
                type: "folder",
                label: "SkinChanger",
                open: !1
            })

            SDGSDsgdASF.Register([
                { type: 'checkbox', label: 'Gauges', object: Settings, property: 'gaugesInfo', onChange: data => { kasdgiksadg.saveSettings(); } },
                { type: 'checkbox', label: 'Tracers', object: Settings, property: 'tracers', onChange: data => { kasdgiksadg.saveSettings(); } },
                { type: 'checkbox', label: 'BuildInfo', object: Settings, property: 'buildinfo', onChange: data => { kasdgiksadg.saveSettings(); } },
                { type: 'checkbox', label: 'TotemInfo', object: Settings, property: 'toteminfo', onChange: data => { kasdgiksadg.saveSettings(); } },
                // { type: 'checkbox', label: 'Xray', object: Settings.xray, property: 'e', onChange: data => { kasdgiksadg.saveSettings(); } },
                // { type: 'checkbox', label: 'NoFog', object: Settings, property: 'NoFog', onChange: data => { kasdgiksadg.saveSettings(); } },
                // { type: 'checkbox', label: 'ListEnabledHacks', object: Settings, property: 'ListEnabledHacks', onChange: data => { kasdgiksadg.saveSettings(); } },
                // { type: 'checkbox', label: 'PlayerOnTop', object: Settings, property: 'playerOnTop', onChange: data => { kasdgiksadg.saveSettings(); } },
                // { type: 'checkbox', label: 'BoxOnTop', object: Settings, property: 'boxOnTop', onChange: data => { kasdgiksadg.saveSettings(); } },
                // { type: 'checkbox', label: 'WeatherInfo', object: Settings, property: 'WeatherInfo', onChange: data => { kasdgiksadg.saveSettings(); } },
                // { type: 'checkbox', label: 'boxInfo', object: Settings, property: 'boxInfo', onChange: data => { kasdgiksadg.saveSettings(); } },
                // { type: 'checkbox', label: 'ColoredSpikes', object: Settings, property: 'coloredspike', onChange: data => { kasdgiksadg.saveSettings(); } },
                // { type: 'checkbox', label: 'Timers', object: Settings, property: 'Timer', onChange: data => { kasdgiksadg.saveSettings(); } },
                // { type: 'checkbox', label: 'BetterQuestTime', object: Settings, property: 'BetterQuestTime', onChange: data => { kasdgiksadg.saveSettings(); } },
                // { type: 'checkbox', label: 'Percents', object: Settings, property: 'Percent', onChange: data => { } },
                // { type: 'checkbox', label: 'ShowNames', object: Settings, property: 'ShowNames', onChange: data => { } },

                // { type: "range", label: "RoofsXray", min: 0, max: 1, step: 0.1, object: Settings.roofs, property: "o", onChange: data => { kasdgiksadg.saveSettings() } },
                // { type: "range", label: "Xray", min: 0, max: 1, step: 0.1, object: Settings.xray, property: "o", onChange: data => { kasdgiksadg.saveSettings() } },
            ], {
                folder: "Visuals"
            });

            SDGSDsgdASF.Register([
                { type: 'checkbox', label: 'AutoSteal', object: Settings.AutoSteal, property: 'e', onChange: data => { kasdgiksadg.saveSettings(); } },
                { type: 'checkbox', label: 'AutoExtractorPut', object: Settings.AutoExtractorPut, property: 'e', onChange: data => { kasdgiksadg.saveSettings(); } },
                { type: 'checkbox', label: 'AutoExtractorTake', object: Settings.AutoExtractorTake, property: 'e', onChange: data => { kasdgiksadg.saveSettings(); } },
            ], {
                folder: "Misc"
            });

            SDGSDsgdASF.Register([
                { type: 'checkbox', label: 'AutoCraft', object: Settings.AutoCraft, property: 'e', onChange: data => { kasdgiksadg.saveSettings(); } },
                { type: 'checkbox', label: 'SafeMode', object: Settings.AutoCraft, property: 's', onChange: data => { kasdgiksadg.saveSettings(); } },
                { type: 'display', label: 'AutoCraft Key:', object: Settings.AutoCraft, property: 'k' },
                { type: 'button', label: 'Set AutoCraft Key', action: data => { kasdgiksadg.controls.setKeyBind('AutoCraft'); } },
                { type: 'display', label: 'CraftId: ', object: Settings.AutoCraft, property: 'lastcraft' },
                { type: 'display', label: '' },
                { type: 'checkbox', label: 'AutoRecycle', object: Settings.AutoRecycle, property: 'e', onChange: data => { kasdgiksadg.saveSettings(); } },
                { type: 'checkbox', label: 'SafeMode', object: Settings.AutoRecycle, property: 's', onChange: data => { kasdgiksadg.saveSettings(); } },
                { type: 'display', label: 'AutoRecycle Key:', object: Settings.AutoRecycle, property: 'k' },
                { type: 'button', label: 'Set AutoRecycle Key', action: data => { kasdgiksadg.controls.setKeyBind('AutoRecycle'); } },
                { type: 'display', label: 'RecycleId: ', object: Settings.AutoRecycle, property: 'lastrecycle' },
            ], {
                folder: "AutoCraft & AutoRecycle"
            });

            SDGSDsgdASF.Register([
                { type: 'display', label: 'AutoSteal Key:', object: Settings.AutoSteal, property: 'k' },
                { type: 'button', label: 'Set AutoSteal Key', action: data => { kasdgiksadg.controls.setKeyBind('AutoSteal'); } },
                { type: 'display', label: 'AutoExtractorPut Key:', object: Settings.AutoExtractorPut, property: 'k' },
                { type: 'button', label: 'Set AutoExtractorPut Key', action: data => { kasdgiksadg.controls.setKeyBind('AutoExtractorPut'); } },
                { type: 'display', label: 'AutoExtractorTake Key:', object: Settings.AutoExtractorTake, property: 'k' },
                { type: 'button', label: 'Set AutoExtractorTake Key', action: data => { kasdgiksadg.controls.setKeyBind('AutoExtractorTake'); } },
                // { type: 'display', label: 'Aimbot Key:', object: Settings.aimbot, property: 'k' },
                // { type: 'button', label: 'Set Aimbot Key', action: data => { kasdgiksadg.controls.setKeyBind('aimbot'); } },
                // { type: 'display', label: 'AutoSteal Key:', object: Settings.AutoSteal, property: 'k' },
                // { type: 'button', label: 'Set AutoSteal Key', action: data => { kasdgiksadg.controls.setKeyBind('AutoSteal'); } },
                // { type: 'display', label: 'Spectator Key:', object: Settings.spectator, property: 'k' },
                // { type: 'button', label: 'Set Spectator Key', action: data => { kasdgiksadg.controls.setKeyBind('spectator'); } },
                // { type: 'display', label: 'DropSword Key:', object: Settings.DropSword, property: 'k' },
                // { type: 'button', label: 'Set DropSword Key', action: data => { kasdgiksadg.controls.setKeyBind('DropSword'); } },
            ], { folder: "Bind" });

            SDGSDsgdASF.Register([
                { type: 'button', label: 'Set AutoSpike Key', action: data => { kasdgiksadg.controls.setKeyBind('AutoSpike'); } },
                { type: 'display', label: 'AutoSpike Key:', object: Settings.AutoSpike, property: 'k' },
                { type: 'select', label: '1', object: Settings.AutoSpike.p, property: "0", options: ['Reidite Spike', 'Amethyst Spike', 'Diamond Spike', 'Gold Spike', 'Stone Spike', 'Wood Spike', 'Wood Wall', "Resurrection", "Nothing"], onChange: (data) => { kasdgiksadg.saveSettings(); } },
                { type: 'select', label: '2', object: Settings.AutoSpike.p, property: "1", options: ['Reidite Spike', 'Amethyst Spike', 'Diamond Spike', 'Gold Spike', 'Stone Spike', 'Wood Spike', 'Wood Wall', "Resurrection", "Nothing"], onChange: (data) => { kasdgiksadg.saveSettings(); } },
                { type: 'select', label: '3', object: Settings.AutoSpike.p, property: "2", options: ['Reidite Spike', 'Amethyst Spike', 'Diamond Spike', 'Gold Spike', 'Stone Spike', 'Wood Spike', 'Wood Wall', "Resurrection", "Nothing"], onChange: (data) => { kasdgiksadg.saveSettings(); } },
                { type: 'select', label: '4', object: Settings.AutoSpike.p, property: "3", options: ['Reidite Spike', 'Amethyst Spike', 'Diamond Spike', 'Gold Spike', 'Stone Spike', 'Wood Spike', 'Wood Wall', "Resurrection", "Nothing"], onChange: (data) => { kasdgiksadg.saveSettings(); } },
                { type: 'select', label: '5', object: Settings.AutoSpike.p, property: "4", options: ['Reidite Spike', 'Amethyst Spike', 'Diamond Spike', 'Gold Spike', 'Stone Spike', 'Wood Spike', 'Wood Wall', "Resurrection", "Nothing"], onChange: (data) => { kasdgiksadg.saveSettings(); } },
                { type: 'select', label: '6', object: Settings.AutoSpike.p, property: "5", options: ['Reidite Spike', 'Amethyst Spike', 'Diamond Spike', 'Gold Spike', 'Stone Spike', 'Wood Spike', 'Wood Wall', "Resurrection", "Nothing"], onChange: (data) => { kasdgiksadg.saveSettings(); } },
                { type: 'select', label: '7', object: Settings.AutoSpike.p, property: "6", options: ['Reidite Spike', 'Amethyst Spike', 'Diamond Spike', 'Gold Spike', 'Stone Spike', 'Wood Spike', 'Wood Wall', "Resurrection", "Nothing"], onChange: (data) => { kasdgiksadg.saveSettings(); } },
            ], { folder: "AutoSpike" });

            // SDGSDsgdASF.Register([
            //     { type: 'checkbox', label: 'AutoBook', object: Settings, property: 'AutoBook', onChange: data => { kasdgiksadg.saveSettings(); } },
            //     { type: 'checkbox', label: 'AutoSteal', object: Settings.AutoSteal, property: 'e', onChange: data => { kasdgiksadg.saveSettings(); } },
            //     { type: 'checkbox', label: 'Spectator', object: Settings.spectator, property: 'e', onChange: data => { kasdgiksadg.saveSettings(); } },
            //     { type: 'checkbox', label: 'Aimbot', object: Settings.aimbot, property: 'e', onChange: data => { kasdgiksadg.saveSettings(); } },
            //     { type: 'checkbox', label: 'AutoRespawn', object: Settings, property: 'AutoRespawn', onChange: data => { kasdgiksadg.saveSettings(); } },

            //     { type: "range", label: "SpectatorSpeed", min: 10, max: 200, step: 5, object: Settings.spectator, property: "s", onChange: data => { kasdgiksadg.saveSettings() } },
            // ], { folder: "Misc" });
            // SDGSDsgdASF.Register([
            //     { type: 'checkbox', label: 'AutoCraft', object: Settings.AutoCraft, property: 'e', onChange: data => { kasdgiksadg.saveSettings(); } },
            //     { type: 'display', label: 'AutoCraft Key:', object: Settings.AutoCraft, property: 'k' },
            //     { type: 'button', label: 'Set AutoCraft Key', action: data => { kasdgiksadg.controls.setKeyBind('AutoCraft'); } },
            //     { type: 'display', label: 'CraftId: ', object: Settings.AutoCraft, property: 'last' },
            //     { type: 'display', label: '' },
            //     { type: 'checkbox', label: 'AutoRecycle', object: Settings.AutoRecycle, property: 'e', onChange: data => { kasdgiksadg.saveSettings(); } },
            //     { type: 'display', label: 'AutoRecycle Key:', object: Settings.AutoRecycle, property: 'k' },
            //     { type: 'button', label: 'Set AutoRecycle Key', action: data => { kasdgiksadg.controls.setKeyBind('AutoRecycle'); } },
            //     { type: 'display', label: 'RecycleId: ', object: Settings.AutoRecycle, property: 'last' },
            // ], { folder: "AutoCraft&Recycle" });

            SDGSDsgdASF.Register([
                {
                    type: "select",
                    label: "Skin",
                    options: skins,
                    onChange: e => {
                        script.myPlayer.skin = skins.indexOf(e);
                        Settings.SkinChanger_Skin = skins.indexOf(e);
                    }
                }
            ], {
                folder: "SkinChanger"
            })

        },
        controls: null,
        controller: class {
            setKeyBind(callback) {
                Settings[callback].k = 'Press any key';
                let click = 0;
                unsafeWindow.document.addEventListener('keydown', function abc(event) {
                    click++;
                    if (click >= 1) {
                        if (event.code == "Escape") {
                            Settings[callback].k = "NONE";
                        } else {
                            Settings[callback].k = event.code;
                        };
                        unsafeWindow.document.removeEventListener('keydown', abc);
                        kasdgiksadg.saveSettings();
                    };
                });
            }
        },
        saveSettings: () => {
            for (let e in Settings) localStorage.setItem(e + "ZOV", JSON.stringify(Settings[e]))
        },
        loadSettings: () => {
            for (let e in Settings) {
                let o = localStorage.getItem(e + "ZOV");
                o && (Settings[e] = JSON.parse(o))
            }
        },
        LoadHack: () => {
            document.addEventListener("keydown", (e) => {
                if (chatxterm()) return;
                switch (e.code) {
                    case Settings.AutoSpike.k:
                        Settings.AutoSpike.e = true;
                    break;
                    case Settings.AutoSteal.k:
                        Settings.AutoSteal.e = true;
                    break;
                    case Settings.AutoExtractorPut.k:
                        Settings.AutoExtractorPut.e = !Settings.AutoExtractorPut.e
                        break;
                }
            });

            document.addEventListener("keyup", (e) => {
                if (chatxterm()) return;
                switch (e.code) {
                    case Settings.AutoSpike.k:
                        Settings.AutoSpike.e = false;
                    break;
                    case Settings.AutoSteal.k:
                        Settings.AutoSteal.e = false;
                    break;
                    case Settings.AutoCraft.k:
                        Settings.AutoCraft.e = !Settings.AutoCraft.e;
                    break;
                    case Settings.AutoRecycle.k:
                        Settings.AutoRecycle.e = !Settings.AutoRecycle.e;
                    break;

                }
            });
            for (let i = 0; i < 236; i++) {
                if (i <= 222) {
                    lootboxes.push("LootBox: " + i);
                }
                skins.push("Skin: " + i);
            }
            kasdgiksadg.loadSettings();
            kasdgiksadg.controls = new kasdgiksadg.controller();
            let e = unsafeWindow.document.createElement("script");
            e.onload = function () {
                setTimeout(kasdgiksadg.KILLUKRSOLIDER, 500)
            }, e.src = "https://unpkg.com/guify@0.12.0/lib/guify.min.js", unsafeWindow.document.body.appendChild(e)
        },
    };

    setTimeout(kasdgiksadg.LoadHack(), 3500)
}, 500);



let LAST_CRAFT;

let world;
let client;
let user;
let mouse
let _this;
let log = console.log
let LAST_RECYCLE
let master = Symbol()

function hooks() {
    Object.defineProperty(Object.prototype, "timeout", {
        get() {
            return this[master]
        },
        set(data) {
            this[master] = data;
            if (!client) {
                client = this;
                unsafeWindow.client = client;
            }
        },
    })
    Object.defineProperty(Object.prototype, "IDLE", {
        get() {
            return this[master]
        },
        set(data) {
            this[master] = data;
            if (!mouse) {
                mouse = this;
                unsafeWindow.mouse = mouse;
            }
        },
    })
    Object.defineProperty(Object.prototype, "opacity", {
        get() {
            this[master] = 0.5
            return this[master]

        },
        set(data) {
            this[master] = data;

        },
    })
    Object.defineProperty(Screen.prototype, "width", {
        get: function () {
            return 3840;
        },
        set: function (v) {
            this[master] = v;
        }
    });
    Object.defineProperty(Screen.prototype, "height", {
        get: function () {
            return 2160;
        },
        set: function (v) {
            this[master] = v;
        }
    });
    Object.defineProperty(Object.prototype, "mode", {
        get() {
            return this[master]
        },
        set(data) {
            this[master] = data;
            if (!world) {
                world = this;
                unsafeWindow.world = world;
            }
        },
    })

    Object.defineProperty(Object.prototype, "control", {
        get() {
            return this[master]
        },
        set(data) {
            this[master] = data;
            if (!user) {
                user = this;
                user[Object.keys(user)[10]] = false // alive
                unsafeWindow.user = user;
                ads()
            }
        },
    })
}


hooks()
//////////////////////////////////////////////////////////////////////////////

function send(data) {
    let sock;
    let counter = 0;

    for (let prop1 in client) {
        counter++;

        if (counter === 1) {
            sock = prop1;
            break;
        }
    }


    client[sock].send(JSON.stringify(data))
}
function unit() {
    let units;
    let counter = 0;

    for (let prop1 in world) {
        counter++;

        if (counter === 5) {
            units = world[prop1];
            break;
        }
    }
    return units;

}


function myplayer() {
    let fast_units;
    let counter = 0;

    let pid
    let counter2 = 0

    for (let prop1 in user) {
        counter2++;

        if (counter2 === 18) {
            pid = user[prop1];
            break;
        }
    }

    for (
        let prop1 in world) {
        counter++;

        if (counter === 6) {
            fast_units = world[prop1][pid];
            break;
        }
    }
    return fast_units;

}

function pid(obj) {
    let wow
    if (unit()[0].length > 0) {
        unit()[0].forEach((obj) => {
            for (const e in obj) {
                if (obj[e] == user.id && e !== "info") {
                    wow = e;
                    break; // This will exit the for-in loop
                }
            }
        });
    }

    return obj.ΔⵠⵠⲆ;
}

function chatxterm() {
    if (document.getElementById("chat_block").style.display === 'inline-block' || document.getElementById("commandMainBox").style.display === 'inline-block') {
        return true;
    } else {
        return false;
    }
}

function gauges() {
    let gauge;
    let gauge2;
    let counter = 0;

    for (let prop1 in user) {
        counter++;

        if (counter === 30) {


            gauge = user[prop1];
            let innerCounter = 0;

            for (let prop2 in gauge) {
                innerCounter++;
                if (innerCounter === 3) {
                    gauge2 = gauge[prop2];
                }
            }
            break;
        }
    }
    return gauge2;
}

function gauges2() {
    let gauge;
    let gauge2;
    let counter = 0;

    for (let prop1 in user) {
        counter++;

        if (counter === 30) {


            gauge = user[prop1];
            let innerCounter = 0;

            for (let prop2 in gauge) {
                innerCounter++;
                if (innerCounter === 2) {
                    gauge2 = gauge[prop2];
                }
            }
            break;
        }
    }
    return gauge2;
}

function inventoryHas(id) {

    let inv;
    let inv2;
    let counter = 0;

    for (let prop1 in user) {
        counter++;

        if (counter === 35) {
            inv = user[prop1];
            let counter2 = 0;
            for (let prop2 in inv) {
                counter2++;
                if (counter2 === 4) {
                    inv2 = inv[prop2];
                }
            }
            break;
        }
    }



    if (inv2[id] !== 0 && inv2[id] !== undefined) {
        return [true, inv2[id]]
    } else {
        return [false, undefined]
    }
}


function isAlive() {
    let team;
    let counter = 0;

    for (let prop1 in user) {
        counter++;

        if (counter === 11) {
            team = user[prop1];
            break;
        }
    }

    return team;
}
function getUserPosition() {

    let camx;
    let camy;
    for (let prop1 in user) {
        for (let prop2 in user[prop1]) {
            switch (prop2) {
                case "x":
                    camx = user[prop1][prop2];
                    break;
                case "y":
                    camy = user[prop1][prop2];
                    break;
            }
        }
    }
    return [camx, camy]
}

function drawsp() {
    let drawSpike = null;

    if (drawSpike === null || drawSpike === "null") {
        [5, 12, 13, 14, 20, 52, 10, 15, 16, 17, 21, 51, 45, 46, 47, 48, 49, 53].forEach((id) => {
            if (unit()[id].length > 0) {
                for (let e in unit()[id]) {
                    for (const k in unit()[id][e]) {
                        if (typeof unit()[id][e][k] === "function") {
                            if (unit()[id][e][k].toString().includes("width")) {
                                drawSpike = k;
                                break; // Exit the loop once the key is found
                            }
                        }
                    }
                }
            }
        });
    }
    return drawSpike
}

unsafeWindow.sp = drawsp
function ads() {
    let uwu = document.getElementById("preroll")
    let uws = document.getElementById("trevda")
    let style = document.createElement('style');

    uwu.remove()
    uws.remove()
    style.innerHTML = '.grecaptcha-badge { visibility: hidden; }';

    document.head.appendChild(style);
}

function autoBook() {

    let craft;
    let counter = 0;
    for (let prop1 in client) {
        counter++;
        if (counter === 96) {
            craft = prop1
            break;
        }
    }

    client[craft] = (id) => {

        Settings.AutoCraft.lastcraft = id

        send([packets.equip, 28])
        send([packets.craft, id]);
        return 1;
    };
}

// SOSITE
function isAlly(id) {
    return ally.includes(id);
}

function getdist(a, b) {
    return Math.sqrt(((b.x - a.x) * (b.x - a.x)) + ((b.y - a.y) * (b.y - a.y)));
}

function aimbot() {
    // requestAnimationFrame(aimbot);



    // let myPlayer = myplayer();

    // function HoldWeapon(_, $) {
    //     switch (_) {
    //         case 34:
    //         case 18:
    //         case 33:
    //         case 15:
    //         case 14:
    //         case 13:
    //         case 12:
    //         case 16:
    //         case 17:
    //             return 2;
    //         case 57:
    //         case 5:
    //         case 6:
    //         case 30:
    //         case 62:
    //         case 9:
    //         case 0:
    //         case 63:
    //         case 19:
    //             return 1;
    //         case 64:
    //         case 65:
    //         case 66:
    //         case 67:
    //         case 68:
    //         case 70:
    //         case 69:
    //             return 3;
    //         case 94:
    //         case 95:
    //         case 96:
    //         case 97:
    //         case 98:
    //         case 90:
    //         case 99:
    //             return 6;
    //         case 45:
    //             if ($) return 4;
    //         case -1:
    //             if ($) return 5;
    //     }
    //     return 0;
    // }

    // function calcAngle(_, $, o) {
    //     return _ && $ ? (o ? Math.atan2($.r.y - _.r.y, $.r.x - _.r.x) : Math.atan2($.y - _.y, $.x - _.x)) : null;
    // }

    // function EnemyToAttack(myPlayer, PlayerList) {
    //     let nearest = null;
    //     let distSqrd = -1;
    //     let HoldingSpear = HoldWeapon(myPlayer.right, false) === 2 ? true : false;

    //     for (var i = 0, obj = null, d = null; i < PlayerList.length; ++i) {
    //         obj = PlayerList[i];
    //         if (pid(obj) === pid(myPlayer) || isAlly(pid(obj))) continue; // Skip self and allies
    //         if (!isAlly(pid(obj)) && myPlayer.fly === obj.fly && !obj.ghost) {
    //             d = (myPlayer.x - obj.x) ** 2 + (myPlayer.y - obj.y) ** 2;
    //             if (HoldingSpear && d < 210) continue;
    //             if (distSqrd === -1 || d < distSqrd) {
    //                 distSqrd = d;
    //                 nearest = obj;
    //             }
    //         }
    //     }

    //     if (Settings.AMB.enabled && Settings.AMB.a != null) {

    //         mouse.ᐃⲆᐃᐃ.x = getUserPosition()[0] + nearest.x;
    //         mouse.ᐃⲆᐃᐃ.y = getUserPosition()[1] + nearest.y;
    //     }

    //     return nearest;
    // }

    // function dist2dSQRT(p1, p2) {
    //     if (p1 && p2) {
    //         return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
    //     }
    //     return null;
    // }

    // if (Settings.AMB.enabled && myPlayer && script.user.alive) {
    //     const weaponType = HoldWeapon(myPlayer.right, true);
    //     let myRange;
    //     switch (weaponType) {
    //         case 1:
    //             myRange = myPlayer.fly ? 196.8 : 157.6;
    //             break;
    //         case 2:
    //             myRange = myPlayer.fly ? 291.8 : 227.6;
    //             break;
    //         case 3:
    //             myRange = 620;
    //             break;
    //         case 4:
    //             myRange = myPlayer.fly ? 140 : 125;
    //             break;
    //         case 5:
    //             myRange = myPlayer.clothe == 85 || myPlayer.clothe == 83 ? (myPlayer.fly ? 120.8 : 97.6) : null;
    //             break;
    //         default:
    //             myRange = null;
    //             break;
    //     }
    //     if (myRange) {
    //         const Enemy = EnemyToAttack(myPlayer, unit()[0]);
    //         if (Enemy) {
    //             const RangeBetweenMeAndEnemy = dist2dSQRT(myPlayer, Enemy);
    //             if (RangeBetweenMeAndEnemy <= myRange) {
    //                 Settings.AMB.a = calcAngle(myPlayer, Enemy, true);
    //                 Settings.AMB.t = Enemy;
    //                 const e = 2 * Math.PI;
    //                 const Angle255 = Math.floor((((Settings.AMB.a + e) % e) * 255) / e);

    //                 send([packets.angle, Angle255]);
    //                 if (Settings.AMB.a && RangeBetweenMeAndEnemy <= myRange - 22) {
    //                     send([packets.attack, Angle255]);
    //                     send([packets.stopAttack]);
    //                 }
    //             } else {
    //                 Settings.AMB.a = null;
    //                 Settings.AMB.t = null;
    //             }
    //         } else {
    //             Settings.AMB.a = null;
    //         }
    //     }
    // }
}

function blizzard() {

    let blizzard1;
    let sandstorm
    let tempset;
    let counter = 0;

    for (let prop1 in user) {
        counter++;

        if (counter === 37) {
            autofeed = user[prop1]
        }
        if (counter === 47) {
            sandstorm = user[prop1]
        }

        if (counter === 48) {

            let innerCounter = 0;

            for (let prop2 in user[prop1]) {
                innerCounter++;
                if (innerCounter === 2) {
                    blizzard1 = user[prop1];
                    unsafeWindow.blizz1 = blizzard1
                    tempset = [prop2]
                }
            }
            break;
        }
    }

    requestAnimationFrame(blizzard)
    var use = -8;

    const canvas = document.getElementById("game_canvas");
    const ctx = canvas.getContext("2d");

    if (script.user.alive && blizzard1[tempset]) { //27
        ctx.save();
        ctx.drawImage(
            BlizzardImage,
            autofeed.translate.x - 70,
            autofeed.translate.y + use
        );
        use += 70;
    }
    if (script.user.alive && sandstorm[tempset]) { //26
        ctx.save();
        ctx.drawImage(
            SandstormImage,
            autofeed.translate.x - 70,
            autofeed.translate.y + use
        );
        use += 70;
    }
}
let ally = [];
const extractor_ids = [24, 25, 26, 27, 28];
const foodItems = [110, 117]

function colors() {
    if (script.user.alive && Settings.ColoredSpikes.enabled) {
        unsafeWindow.ReiditeSpikeAlly = new Image;
        unsafeWindow.ReiditeSpikeAlly.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-reidite-spike-ally.png"
        unsafeWindow.AmethystSpikeAlly = new Image;
        unsafeWindow.AmethystSpikeAlly.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-amethyst-spike-ally.png"
        unsafeWindow.DiamondSpikeAlly = new Image;
        unsafeWindow.DiamondSpikeAlly.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-diamond-spike-ally.png"
        unsafeWindow.GoldSpikeAlly = new Image;
        unsafeWindow.GoldSpikeAlly.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-gold-spike-ally.png"
        unsafeWindow.StoneSpikeAlly = new Image;
        unsafeWindow.StoneSpikeAlly.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-stone-spike-ally.png"
        unsafeWindow.WoodSpikeAlly = new Image;
        unsafeWindow.WoodSpikeAlly.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-wood-spike-ally.png"

        unsafeWindow.ReiditeSpikeEnemy = new Image;
        unsafeWindow.ReiditeSpikeEnemy.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-reidite-spike-enemy.png"
        unsafeWindow.AmethystSpikeEnemy = new Image;
        unsafeWindow.AmethystSpikeEnemy.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-amethyst-spike-enemy.png"
        unsafeWindow.DiamondSpikeEnemy = new Image;
        unsafeWindow.DiamondSpikeEnemy.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-diamond-spike-enemy.png"
        unsafeWindow.GoldSpikeEnemy = new Image;
        unsafeWindow.GoldSpikeEnemy.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-gold-spike-enemy.png"
        unsafeWindow.StoneSpikeEnemy = new Image;
        unsafeWindow.StoneSpikeEnemy.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-stone-spike-enemy.png"
        unsafeWindow.WoodSpikeEnemy = new Image;
        unsafeWindow.WoodSpikeEnemy.src = "https://raw.githubusercontent.com/sfagasdzdgfhs/spikes/main/day-wood-spike-enemy.png"

        let ITEMS = {
            SPIKE: 5,
            STONE_SPIKE: 12,
            GOLD_SPIKE: 13,
            DIAMOND_SPIKE: 14,
            AMETHYST_SPIKE: 20,
            REIDITE_SPIKE: 52,
        }

        unsafeWindow.ITEMS_TO_CHECK = {
            SPIKE: 5,
            STONE_SPIKE: 12,
            GOLD_SPIKE: 13,
            DIAMOND_SPIKE: 14,
            AMETHYST_SPIKE: 20,
            REIDITE_SPIKE: 52,
        }
        let chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMOPQRSTUVWXYZ_0123456789";

        for (let e in unsafeWindow) {
            if (!Array.isArray(unsafeWindow[e]) && chars.includes(e[0])) continue;
            if (unsafeWindow[e].length > 800 && unsafeWindow[e].length < 1500) unsafeWindow.sprite = unsafeWindow[e];
        }
        sprite[10000] = [WoodSpikeAlly, WoodSpikeAlly];
        sprite[10001] = [WoodSpikeEnemy, WoodSpikeEnemy];

        sprite[10002] = [StoneSpikeAlly, StoneSpikeAlly];
        sprite[10003] = [StoneSpikeEnemy, StoneSpikeEnemy];

        sprite[10004] = [GoldSpikeAlly, GoldSpikeAlly];
        sprite[10005] = [GoldSpikeEnemy, GoldSpikeEnemy];

        sprite[10006] = [DiamondSpikeAlly, DiamondSpikeAlly];
        sprite[10007] = [DiamondSpikeEnemy, DiamondSpikeEnemy];

        sprite[10008] = [AmethystSpikeAlly, AmethystSpikeAlly];
        sprite[10009] = [AmethystSpikeEnemy, AmethystSpikeEnemy];

        sprite[10010] = [ReiditeSpikeAlly, ReiditeSpikeAlly];
        sprite[10011] = [ReiditeSpikeEnemy, ReiditeSpikeEnemy];

        let push = Array.prototype.push
        Array.prototype.push = function (p) {
            if (p) {
                let a = Object.keys(p);
                5 == a.length && a.includes("draw") && a.includes("in_button") && 32 !== p.id && 130 !== p.id && 127 !== p.id && 4 !== p.id && 25 !== p.id && 34 !== p.id && 87 !== p.id && (unsafeWindow.inventory = this);
            }
            unsafeWindow.wow = 'Δⵠᐃⵠ'
            if (p && null != p.type && null != p.id && p.x && p.y)
                switch ((0 === p.type && pid(p) === unsafeWindow.playerID && (unsafeWindow.player = p), p.type)) {

                    case ITEMS.SPIKE: {
                        p.ally = unsafeWindow.playerID === pid(p) || isAlly(pid(p));
                        let l = p[wow]; // draw
                        p[wow] = function (a) {
                            return Settings.ColoredSpikes ? (p.ally ? l.apply(this, [1e4]) : l.apply(this, [10001])) : l.apply(this, arguments);
                        };
                        break;
                    }
                    case ITEMS.STONE_SPIKE: {
                        p.ally = unsafeWindow.playerID === pid(p) || isAlly(pid(p));
                        let i = p[wow]; // draw
                        p[wow] = function (a) {
                            return Settings.ColoredSpikes ? (p.ally ? i.apply(this, [10002]) : i.apply(this, [10003])) : i.apply(this, arguments);
                        };
                        break;
                    }
                    case ITEMS.GOLD_SPIKE: {
                        p.ally = unsafeWindow.playerID === pid(p) || isAlly(pid(p));
                        let e = p[wow]; // draw
                        p[wow] = function (a) {
                            return Settings.ColoredSpikes ? (p.ally ? e.apply(this, [10004]) : e.apply(this, [10005])) : e.apply(this, arguments);
                        };
                        break;
                    }
                    case ITEMS.DIAMOND_SPIKE: {
                        p.ally = unsafeWindow.playerID === pid(p) || isAlly(pid(p));
                        let t = p[wow]; // draw
                        p[wow] = function (a) {
                            return Settings.ColoredSpikes ? (p.ally ? t.apply(this, [10006]) : t.apply(this, [10007])) : t.apply(this, arguments);
                        };
                        break;
                    }
                    case ITEMS.AMETHYST_SPIKE: {
                        p.ally = unsafeWindow.playerID === pid(p) || isAlly(pid(p));
                        let r = p[wow]; // draw
                        p[wow] = function (a) {
                            return Settings.ColoredSpikes ? (p.ally ? r.apply(this, [10008]) : r.apply(this, [10009])) : r.apply(this, arguments);
                        };
                        break;
                    }
                    case ITEMS.REIDITE_SPIKE: {
                        p.ally = unsafeWindow.playerID === pid(p) || isAlly(pid(p));
                        let y = p[wow]; // draw
                        p[wow] = function (a) {
                            return Settings.ColoredSpikes ? (p.ally ? y.apply(this, [10010]) : y.apply(this, [10011])) : y.apply(this, arguments);
                        };
                        break;
                    }
                    case unit()[0]: {
                        let w = p[wow]
                    }
                }
            return push.apply(this, arguments);
        };
    }
}

function updater() {
    requestAnimationFrame(updater)

    unsafeWindow.ctx = document.getElementById("game_canvas").getContext("2d");

    script.user.alive = user[Object.keys(user)[10]];

    for (hack in Settings) {
        let i = 22.5;
        if (Settings[hack].e && Settings[hack].k) {
            ctx.save();
            ctx.beginPath();
            ctx.lineWidth = 6;
            ctx.fillStyle = "red";
            ctx.strokeStyle = "black";
            ctx.font = "22px Baloo Paaji";
            ctx.strokeText(hack, 3, i);
            ctx.fillText(hack, 3, i);
            ctx.restore();
            i += 22.5;
        }
    }
    if (Settings.textalert.e) {
        ctx.save();
        ctx.beginPath();
        ctx.lineWidth = 6;
        ctx.fillStyle = "red";
        ctx.strokeStyle = "black";
        ctx.font = "55px Baloo Paaji";
        ctx.strokeText(Settings.textalert.t, unsafeWindow.innerWidth / 2, unsafeWindow.innerHeight / 14);
        ctx.fillText(Settings.textalert.t, unsafeWindow.innerWidth / 2, unsafeWindow.innerHeight / 14);
        ctx.restore();
    }

    if (script.user.alive) {

        let gauges = user[Object.keys(user)[29]]
        script.world.units = world[Object.keys(world)[4]]
        script.world.fast_units = world[Object.keys(world)[5]]
        script.user.id = user.id;
        script.user.uid = user[Object.keys(user)[17]]
        script.user.gauges.health = Math.floor(gauges[Object.keys(gauges)[1]] * 200)
        script.user.gauges.hungry = Math.floor(gauges[Object.keys(gauges)[2]] * 100)
        script.user.gauges.cold = Math.floor(gauges.c * 100) + Math.floor(100 - (gauges[Object.keys(gauges)[5]] * 100))
        script.user.gauges.water = Math.floor(gauges[Object.keys(gauges)[3]] * 100)

        script.user.cam.x = user[Object.keys(user)[28]].x
        script.user.cam.y = user[Object.keys(user)[28]].y
        script.user.team = user[Object.keys(user)[21]]

        let myPlayer = script.world.fast_units[script.user.uid]
        if (myPlayer) {
            script.myPlayer.skin = myPlayer[Object.keys(myPlayer)[14]];
            script.myPlayer.lootbox = myPlayer[Object.keys(myPlayer)[1]];
            myPlayer[Object.keys(myPlayer)[14]] = Settings.SkinChanger_Skin;
            myPlayer[Object.keys(myPlayer)[1]] = Settings.SkinChanger_LootBox;
            script.myPlayer.angle = myPlayer.angle;
        }



        script.myPlayer.x = myPlayer.x
        script.myPlayer.y = myPlayer.y
        script.myPlayer.ghost = myPlayer[Object.keys(myPlayer)[64]]

        ally = script.user.team.length > 0 ? script.user.team : [script.user.id];

        if (Settings.gaugesInfo) {
            const r = unsafeWindow.innerWidth / 2;
            const a = unsafeWindow.innerHeight - 50;
            let hp = script.user.gauges.health
            let food = script.user.gauges.hungry
            let timeNow = performance.now();

            ctx.save();
            ctx.beginPath();
            ctx.lineWidth = 7;
            ctx.fillStyle = "red";
            ctx.strokeStyle = "black";
            ctx.font = "34px Baloo Paaji";

            ctx.strokeText(hp + "", r - 270 - 100, a - 70);
            ctx.fillText(hp + "", r - 270 - 100, a - 70);

            ctx.strokeText(food + "", r - 110, a - 70);
            ctx.fillText(food + "", r - 110, a - 70);

            ctx.strokeText(script.user.gauges.cold + "", r + 210 - 100, a - 70);
            ctx.fillText(script.user.gauges.cold + "", r + 210 - 100, a - 70);

            ctx.strokeText(script.user.gauges.water + "", r + 450 - 100, a - 70);
            ctx.fillText(script.user.gauges.water + "", r + 450 - 100, a - 70);

            if (hp > script.lastHeal) {
                script.lastHealTime = performance.now();
            }
            if (food < script.lastHungry) {
                script.lastTimer = performance.now();
            }

            let healTimer = Math.round(10 - (timeNow - script.lastHealTime) / 1000);
            let otherTimer = Math.round(5 - (timeNow - script.lastTimer) / 1000);
            if (!isNaN(healTimer)) {
                if (healTimer > 10 || healTimer < 0) script.lastHealTime = performance.now();
                ctx.strokeText(healTimer + "s", r - 150 - 100, a - 40);
                ctx.fillText(healTimer + "s", r - 150 - 100, a - 40);
            }
            if (!isNaN(otherTimer)) {
                ctx.strokeText(otherTimer + "s", r + 90 - 100, a - 40);
                ctx.fillText(otherTimer + "s", r + 90 - 100, a - 40);
            }

            script.lastHeal = hp;
            script.lastHungry = food;

            ctx.restore();
        }
        if (Settings.tracers) {
            const players = script.world.units[0];
            ctx.save();
            for (let i = 0; i < players.length; i++) {
                const pid = players[i][Object.keys(players[i])[1]]
                if (pid === script.user.id) continue;
                ctx.lineWidth = 2.6;
                ctx.beginPath();
                ctx.moveTo(script.user.cam.x + myPlayer.x, script.user.cam.y + myPlayer.y);
                ctx.lineTo(script.user.cam.x + players[i].x, script.user.cam.y + players[i].y);
                ctx.strokeStyle = isAlly(pid) ? "cyan" : "red";
                ctx.stroke();
            };
            ctx.restore();
        }

        if (Settings.toteminfo) {
            let totems = script.world.units[29];
            ctx.save();
            for (let i = 0; i < totems.length; i++) {
                ctx.font = '20px Baloo Paaji';
                ctx.strokeStyle = "black";
                ctx.lineWidth = 7;
                ctx.fillStyle = "white";
                ctx.strokeText(totems[i].info >= 16 ? "🤵" + totems[i].info % 16 : "🤵" + totems[i].info, script.user.cam.x + totems[i].x - 20, script.user.cam.y + totems[i].y -20);
                ctx.fillText(totems[i].info >= 16 ? "🤵" + totems[i].info % 16 : "🤵" + totems[i].info, script.user.cam.x + totems[i].x - 20, script.user.cam.y + totems[i].y - 20);

                ctx.strokeText(totems[i].info >= 16 ? "Lock" : "Open", script.user.cam.x + totems[i].x - 20, script.user.cam.y + totems[i].y + 5);
                ctx.fillText(totems[i].info >= 16 ? "Lock" : "Open", script.user.cam.x + totems[i].x - 20, script.user.cam.y + totems[i].y + 5);
            };
            ctx.restore();
        }

        if (Settings.buildinfo) {
            for (let i = 0; i < extractor_ids.length; ++i) {
                const spikeType = extractor_ids[i];
                const extractors = unit()[spikeType];
                if (script.user.alive) {
                    for (let j = 0; j < extractors.length; j++) {
                        const extractor = extractors[j];
                        ctx.save();
                        ctx.lineWidth = 8;
                        ctx.font = "20px Baloo Paaji";
                        ctx.strokeStyle = "black";
                        ctx.fillStyle = "white";
                        ctx.strokeText(`${extractor.info & 0xFF}` + 'x', extractor.x + script.user.cam.x - 15, extractor.y + script.user.cam.y - 5);
                        ctx.fillText(`${extractor.info & 0xFF}` + 'x', extractor.x + script.user.cam.x - 15, extractor.y + script.user.cam.y - 5);
                        ctx.strokeText(`${(extractor.info & 0xFF00) >> 8}` + 'x', extractor.x + script.user.cam.x - 15, extractor.y + script.user.cam.y + 15);
                        ctx.fillText(`${(extractor.info & 0xFF00) >> 8}` + 'x', extractor.x + script.user.cam.x - 15, extractor.y + script.user.cam.y + 15);
                        ctx.restore();
                    }
                }
            }
        }

    }
}

function mainscript() {
    if (!script.user.alive) return
    if (Settings.AutoExtractorPut.e) {
        extractor_ids.forEach((extractorType) => {
            var extractor = unit()[extractorType];
            if (!chatxterm()) {
                for (let i = 0; i < extractor.length; ++i) {
                    if (getdist(script.myPlayer, extractor[i]) <= 300) {
                        const pid = extractor[i][Object.keys(extractor[i])[1]]
                        send([packets.extPut, 20, pid, extractor[i].id, extractorType]);
                    }
                }
            }
        });
    }
    if (Settings.AutoExtractorTake.e || Settings.AutoSteal.e) {
        extractor_ids.forEach((extractorType) => {
            var extractor = unit()[extractorType];
            if (!chatxterm()) {
                for (let i = 0; i < extractor.length; ++i) {
                    if (getdist(script.myPlayer, extractor[i]) <= 300) {
                        const pid = extractor[i][Object.keys(extractor[i])[1]]
                        send([packets.extTake, pid, extractor[i].id, extractorType]);
                    }
                }
            }
        });
    }
    if (Settings.AutoSteal.e) {
        var chests = unit()[11];
        for (let i = 0; i < chests.length; ++i) {
            if (getdist(script.myPlayer, chests[i]) <= 300) {
                const pid = chests[i][Object.keys(chests[i])[1]]
                send([packets.chestTake, pid, chests[i].id]);
            }
        }
    }
    if (Settings.AutoCraft.lastcraft != -1 && Settings.AutoCraft.e) {
        if (Settings.AutoCraft.s && script.user.gauges.hungry < 60) {
            let isEated = false
            for (const item of foodItems) {
                if (inventoryHas(item)[0]) {
                    send([packets.equip, item])
                    isEated = true;
                }
            }
            if (!isEated && Settings.AutoCraft.s) {
                showalert("AutoCraft disabled. No food", 5000)
                Settings.AutoCraft.e = false
            }
        } else {
            send([packets.craft, Settings.AutoCraft.lastcraft]);
        }
    }

    if (Settings.AutoRecycle.lastcraft != -1 && Settings.AutoRecycle.e) {
        if (Settings.AutoRecycle.s && script.user.gauges.hungry < 60) {
            let isEated = false
            for (const item of foodItems) {
                if (inventoryHas(item)[0]) {
                    send([packets.equip, item])
                    isEated = true;
                }
            }
            if (!isEated && Settings.AutoRecycle.s) {
                showalert("AutoCraft disabled. No food", 5000)
                Settings.AutoRecycle.e = false
            }
        } else {
            send([packets.recycle, Settings.AutoRecycle.lastrecycle]);
        }
    }
    if (script.user.gauges.hungry < 35) {
        for (const item of foodItems) {
            if (inventoryHas(item)[0]) {
                send([packets.equip, item])
            }
        }
    }
    if (Settings.AutoSpike.e && !chatxterm()) {
        for (let i = 0, SpikeP = Settings.AutoSpike.p; i < SpikeP.length; i++) {
            var CurrentSpike = SpikeP[i];
            switch (CurrentSpike) {
                case "Reidite Spike":
                    CurrentSpike = 219;
                    break;
                case "Amethyst Spike":
                    CurrentSpike = 123;
                    break;
                case "Diamond Spike":
                    CurrentSpike = 170; //
                    break;
                case "Gold Spike":
                    CurrentSpike = 169; //
                    break;
                case "Stone Spike":
                    CurrentSpike = 168; //
                    break;
                case "Wood Wall":
                    CurrentSpike = 162;
                    break;
                case "Nothing":
                    CurrentSpike = -1;
                    break;
            };
            if (CurrentSpike === -1 || !inventoryHas(CurrentSpike)[0]) continue;
            var spikeid = CurrentSpike;
            break;
        };
        if (spikeid) {
            let angle = Math.floor((((script.myPlayer.angle + Math.PI * 2) % (Math.PI * 2)) * 255) / (Math.PI * 2));
            for (let i = 0; i < 20; i++) {
                send([packets.placeBuild, spikeid, (angle - i + 255) % 255, 0]);
            }
        };
    }
}

function showalert(text, time) {
    try {
        Settings.textalert.t = text
        Settings.textalert.e = true
        setTimeout(() => {
            Settings.textalert.e = false
        }, parseInt(time));
    } catch (error) { }
}

function circleAngle(t, e, i, s, n) {
    t.beginPath();
    t.lineCap = "round";
    t.arc(e, i, s, 0, Math.PI * 2 * n);
}


function recycle() {

    let rec;
    let counter = 0;

    for (let prop1 in client) {
        counter++;
        if (counter === 116) {
            rec = prop1
            break;
        }
    }

    client[rec] = (id) => {
        Settings.AutoRecycle.lastrecycle = id
        send([packets.recycle, id]);
    };

}

let readys = {
    AutoSpike: true,
    AutoWall: true,
    AutoCraft: true,
};

let autoputredsinterval
let autoputreds = false

let placeSpikesInterval;
let pressed = false;

let autototemInterval;
let autototem = false;

let autoextractortakeInterval;
let autoextractortake = false;

let autoextractorputInterval;
let autoextractorput = false;

let awutostealInterval;
let awutosteal = false;



function main() {
    autoBook()
    blizzard()
    colors()
    aimbot()
    recycle()
    updater()

    setInterval(() => {
        mainscript()
    }, 130);
}

let ready_ = 0;

function initialize() {
    try {
        if (ready_ === 0 && user !== undefined && world !== undefined && client !== undefined) {
            main()
            log("On");
            ready_++;
        }
    } catch (err) {
        log("Off");
        log(err)
    }
}

setInterval(initialize, 1200);